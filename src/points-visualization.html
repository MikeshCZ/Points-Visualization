<!DOCTYPE html>
<html lang="cs">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Vizualizace bod≈Ø z CSV</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #container {
        width: 100vw;
        height: 100vh;
      }
      #status {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 15px;
        border-radius: 5px;
        font-size: 14px;
        min-width: 200px;
      }
      .panel {
        position: absolute;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border-radius: 5px;
        transition: all 0.3s ease;
      }
      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        cursor: pointer;
        user-select: none;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 5px;
      }
      .panel.collapsed .panel-header {
        border-bottom: none;
      }
      .panel-header:hover {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px 5px 0 0;
      }
      .panel.collapsed .panel-header:hover {
        border-radius: 5px;
      }
      .panel-title {
        font-weight: bold;
        font-size: 13px;
      }
      .panel-toggle {
        font-size: 16px;
        transition: transform 0.3s ease;
      }
      .panel-toggle.collapsed {
        transform: rotate(-90deg);
      }
      .panel-content {
        padding: 10px 15px;
        font-size: 12px;
        overflow: hidden;
        transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
      }
      .panel-content.collapsed {
        max-height: 0 !important;
        opacity: 0;
        padding: 0 15px;
      }
      #controls {
        top: 10px;
        left: 10px;
      }
      #fileInput {
        top: 10px;
        right: 10px;
      }
      #displayOptions {
        top: 100px;
        right: 10px;
      }
      input[type="file"] {
        color: white;
      }
      input[type="checkbox"] {
        margin-right: 5px;
        cursor: pointer;
      }
      label {
        cursor: pointer;
      }
      #languageToggle {
        display: none;
      }
      .language-toggle-label {
        cursor: pointer;
        font-size: 20px;
        user-select: none;
        display: block;
        text-align: right;
        margin-bottom: -40px;
      }
      .language-toggle-label:hover {
        opacity: 0.7;
      }
      input[type="range"] {
        width: 150px;
      }
      .slider-container {
        margin: 8px 0;
      }
      .slider-label {
        display: block;
        margin-bottom: 3px;
        font-size: 11px;
      }
      .slider-value {
        display: inline-block;
        min-width: 30px;
        text-align: right;
        margin-left: 5px;
        font-size: 11px;
      }
      strong {
        font-size: 11px;
        color: #aaaaaa;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <div id="status">
      <a
        href="https://michalsara.cz"
        target="_blank"
        rel="noopener noreferrer"
        style="color: #7171fc"
        >Created by Michal ≈†√°ra</a
      >
      | v1.0.4
    </div>
    <div id="controls" class="panel">
      <div class="panel-header" onclick="togglePanel('controls')">
        <span class="panel-title" data-i18n="controls.title">Ovl√°d√°n√≠</span>
        <span class="panel-toggle" id="controls-toggle">‚ñº</span>
      </div>
      <div class="panel-content" id="controls-content">
        <span data-i18n="controls.leftMouse">Lev√© tlaƒç√≠tko my≈°i: Ot√°ƒçen√≠</span
        ><br />
        <span data-i18n="controls.wheel">Koleƒçko my≈°i: Zoom</span><br />
        <span data-i18n="controls.rightMouse"
          >Prav√© tlaƒç√≠tko my≈°i: Posunut√≠</span
        ><br />
        <span data-i18n="controls.middleMouse"
          >Prost≈ôedn√≠ tlaƒç√≠tko: Vybrat st≈ôed ot√°ƒçen√≠</span
        >
      </div>
    </div>
    <div id="fileInput" class="panel">
      <div class="panel-header" onclick="togglePanel('fileInput')">
        <span class="panel-title" data-i18n="fileInput.title">Naƒç√≠st data</span>
        <span class="panel-toggle" id="fileInput-toggle">‚ñº</span>
      </div>
      <div class="panel-content" id="fileInput-content">
        <label for="csvFile" data-i18n="fileInput.selectFile"
          >Vyberte CSV soubor:</label
        >
        <input type="file" id="csvFile" accept=".csv" />
      </div>
    </div>
    <div id="displayOptions" class="panel">
      <div class="panel-header" onclick="togglePanel('displayOptions')">
        <span class="panel-title" data-i18n="displayOptions.title"
          >Mo≈ænosti zobrazen√≠</span
        >
        <span class="panel-toggle" id="displayOptions-toggle">‚ñº</span>
      </div>
      <div class="panel-content" id="displayOptions-content">
        <input type="checkbox" id="languageToggle" />
        <span class="language-toggle-label" id="languageToggleLabel" data-i18n="language.toggle">üá¨üáß</span>
        <br />
        <label>
          <input type="checkbox" id="showAxes" />
          <span data-i18n="displayOptions.showAxes">Zobrazit osov√© k≈ô√≠≈æe</span>
        </label>
        <br />
        <label>
          <input type="checkbox" id="showLabels" />
          <span data-i18n="displayOptions.showLabels">Zobrazit n√°zvy bod≈Ø</span>
        </label>
        <br />
        <label>
          <input type="checkbox" id="useRadians" />
          <span data-i18n="displayOptions.useRadians"
            >Radi√°ny (v√Ωchoz√≠: stupnƒõ)</span
          >
        </label>
        <br />
        <label for="rotationOrder" data-i18n="displayOptions.rotationOrder"
          >Po≈ôad√≠ rotac√≠:</label
        >
        <select id="rotationOrder">
          <option value="XYZ">XYZ</option>
          <option value="XZY">XZY</option>
          <option value="YXZ">YXZ</option>
          <option value="YZX">YZX</option>
          <option value="ZXY">ZXY</option>
          <option value="ZYX">ZYX</option>
        </select>
        <div class="slider-container">
          <span class="slider-label" data-i18n="displayOptions.pointSize"
            >Velikost bod≈Ø:</span
          >
          <input
            type="range"
            id="pointSize"
            min="5"
            max="50"
            value="10"
            step="1"
          />
          <span class="slider-value" id="pointSizeValue">15</span>
        </div>
        <div class="slider-container">
          <span class="slider-label" data-i18n="displayOptions.axesSize"
            >Velikost osov√Ωch k≈ô√≠≈æ≈Ø:</span
          >
          <input
            type="range"
            id="axesSize"
            min="10"
            max="200"
            value="50"
            step="5"
          />
          <span class="slider-value" id="axesSizeValue">50</span>
        </div>
        <div class="slider-container">
          <span class="slider-label" data-i18n="displayOptions.axesOpacity"
            >Transparentnost osov√Ωch k≈ô√≠≈æ≈Ø:</span
          >
          <input
            type="range"
            id="axesOpacity"
            min="0"
            max="100"
            value="90"
            step="5"
          />
          <span class="slider-value" id="axesOpacityValue">0.90</span>
        </div>
        <br />
        <label>
          <input type="checkbox" id="darkMode" checked />
          <span data-i18n="displayOptions.darkMode">Tmav√Ω re≈æim</span>
        </label>
        <br />
        <br />
        <strong data-i18n="displayOptions.axisVisibility"
          >Viditelnost os:</strong
        >
        <br />
        <label>
          <input type="checkbox" id="showAxisX" checked />
          <span data-i18n="displayOptions.showAxisX"
            >Zobrazit osu X (ƒçerven√°)</span
          >
        </label>
        <br />
        <label>
          <input type="checkbox" id="showAxisY" checked />
          <span data-i18n="displayOptions.showAxisY"
            >Zobrazit osu Y (zelen√°)</span
          >
        </label>
        <br />
        <label>
          <input type="checkbox" id="showAxisZ" checked />
          <span data-i18n="displayOptions.showAxisZ"
            >Zobrazit osu Z (modr√°)</span
          >
        </label>
        <br />
        <br />
        <strong data-i18n="displayOptions.axisFlip"
          >Otoƒçen√≠ os (jednotlivƒõ, pouze vizu√°ln√≠):</strong
        >
        <br />
        <label>
          <input type="checkbox" id="flipAxisX" />
          <span data-i18n="displayOptions.flipAxisX">Otoƒçit osu X o 180¬∞</span>
        </label>
        <br />
        <label>
          <input type="checkbox" id="flipAxisY" />
          <span data-i18n="displayOptions.flipAxisY">Otoƒçit osu Y o 180¬∞</span>
        </label>
        <br />
        <label>
          <input type="checkbox" id="flipAxisZ" />
          <span data-i18n="displayOptions.flipAxisZ">Otoƒçit osu Z o 180¬∞</span>
        </label>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
      let scene, camera, renderer, controls;
      let points = [];
      let pointObjects = [];
      let axesObjects = [];
      let labelSprites = [];
      let hoverAxesHelper = null;
      let pivotMarker = null;
      let raycaster, mouse;
      let showAxesMode = false;
      let showLabelsMode = false;
      let useRadians = false;
      let rotationOrder = "XYZ";
      let csvData = null;
      let lastHoveredIndex = null;
      let pointSize = 10;
      let axesSize = 50;
      let axesOpacity = 0.9;
      let isDarkMode = true;
      let showAxisX = true;
      let showAxisY = true;
      let showAxisZ = true;
      let flipAxisX = false;
      let flipAxisY = false;
      let flipAxisZ = false;
      let currentLanguage = "cs"; // Default language

      // Translation object
      const translations = {
        cs: {
          controls: {
            title: "Ovl√°d√°n√≠",
            leftMouse: "Lev√© tlaƒç√≠tko my≈°i: Ot√°ƒçen√≠",
            wheel: "Koleƒçko my≈°i: Zoom",
            rightMouse: "Prav√© tlaƒç√≠tko my≈°i: Posunut√≠",
            middleMouse: "Prost≈ôedn√≠ tlaƒç√≠tko: Vybrat st≈ôed ot√°ƒçen√≠",
          },
          fileInput: {
            title: "Naƒç√≠st data",
            selectFile: "Vyberte CSV soubor:",
          },
          displayOptions: {
            title: "Mo≈ænosti zobrazen√≠",
            showAxes: "Zobrazit osov√© k≈ô√≠≈æe",
            showLabels: "Zobrazit n√°zvy bod≈Ø",
            useRadians: "Radi√°ny (v√Ωchoz√≠: stupnƒõ)",
            rotationOrder: "Po≈ôad√≠ rotac√≠:",
            pointSize: "Velikost bod≈Ø:",
            axesSize: "Velikost osov√Ωch k≈ô√≠≈æ≈Ø:",
            axesOpacity: "Transparentnost osov√Ωch k≈ô√≠≈æ≈Ø:",
            darkMode: "Tmav√Ω re≈æim",
            axisVisibility: "Viditelnost os:",
            showAxisX: "Zobrazit osu X (ƒçerven√°)",
            showAxisY: "Zobrazit osu Y (zelen√°)",
            showAxisZ: "Zobrazit osu Z (modr√°)",
            axisFlip: "Otoƒçen√≠ os (jednotlivƒõ, pouze vizu√°ln√≠):",
            flipAxisX: "Otoƒçit osu X o 180¬∞",
            flipAxisY: "Otoƒçit osu Y o 180¬∞",
            flipAxisZ: "Otoƒçit osu Z o 180¬∞",
          },
          language: {
            toggle: "üá¨üáß",
          },
          status: {
            hover: "Najeƒète my≈°√≠ na bod pro zobrazen√≠ n√°zvu",
            loaded: "Naƒçteno {count} bod≈Ø",
            point: "Bod:",
            pivotPoint: "St≈ôed ot√°ƒçen√≠:",
            worldCenter: "Svƒõtov√Ω st≈ôed",
          },
        },
        en: {
          controls: {
            title: "Controls",
            leftMouse: "Left mouse button: Rotate",
            wheel: "Mouse wheel: Zoom",
            rightMouse: "Right mouse button: Pan",
            middleMouse: "Middle button: Select rotation center",
          },
          fileInput: {
            title: "Load Data",
            selectFile: "Select CSV file:",
          },
          displayOptions: {
            title: "Display Options",
            showAxes: "Show axes",
            showLabels: "Show point labels",
            useRadians: "Radians (default: degrees)",
            rotationOrder: "Rotation order:",
            pointSize: "Point size:",
            axesSize: "Axes size:",
            axesOpacity: "Axes opacity:",
            darkMode: "Dark mode",
            axisVisibility: "Axis visibility:",
            showAxisX: "Show X axis (red)",
            showAxisY: "Show Y axis (green)",
            showAxisZ: "Show Z axis (blue)",
            axisFlip: "Flip axes (individual, visual only):",
            flipAxisX: "Flip X axis 180¬∞",
            flipAxisY: "Flip Y axis 180¬∞",
            flipAxisZ: "Flip Z axis 180¬∞",
          },
          language: {
            toggle: "üá®üáø",
          },
          status: {
            hover: "Hover over a point to display its name",
            loaded: "Loaded {count} points",
            point: "Point:",
            pivotPoint: "Rotation center:",
            worldCenter: "World center",
          },
        },
      };

      // Pro animaci p≈ôesunu kamery
      let isAnimating = false;
      let animationStart = null;
      let animationDuration = 500; // ms
      let startCameraPos = new THREE.Vector3();
      let targetCameraPos = new THREE.Vector3();
      let startControlsTarget = new THREE.Vector3();
      let targetControlsTarget = new THREE.Vector3();

      // Pro animaci zmizen√≠ pivot markeru
      let pivotMarkerFadeStart = null;
      let pivotMarkerFadeDuration = 3000; // 5 sekund

      // Language switching function
      function switchLanguage() {
        currentLanguage = currentLanguage === "cs" ? "en" : "cs";
        updateAllTexts();
      }

      // Update all text elements with current language
      function updateAllTexts() {
        document.querySelectorAll("[data-i18n]").forEach((element) => {
          const key = element.getAttribute("data-i18n");
          const keys = key.split(".");
          let translation = translations[currentLanguage];

          for (const k of keys) {
            translation = translation[k];
          }

          if (translation) {
            element.textContent = translation;
          }
        });

      }

      function togglePanel(panelId) {
        const content = document.getElementById(panelId + "-content");
        const toggle = document.getElementById(panelId + "-toggle");

        if (content.classList.contains("collapsed")) {
          // Rozbalit
          content.classList.remove("collapsed");
          toggle.classList.remove("collapsed");
        } else {
          // Sbalit
          content.classList.add("collapsed");
          toggle.classList.add("collapsed");
        }
      }

      function initPanels() {
        // Nastavit max-height pro v≈°echny panel-content elementy
        const panels = document.querySelectorAll(".panel-content");
        panels.forEach((panel) => {
          panel.style.maxHeight = panel.scrollHeight + "px";
        });
      }

      function init() {
        // Inicializovat panely
        initPanels();

        // Sc√©na
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // Kamera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        camera.position.set(0, 0, 1000);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        // D≈ÆLE≈ΩIT√â: P≈ôidat event listener na canvas P≈òED inicializac√≠ OrbitControls
        // Pou≈æ√≠t pointerdown m√≠sto mousedown - m√° vy≈°≈°√≠ prioritu
        renderer.domElement.addEventListener("pointerdown", onMouseDown, {
          capture: true,
        });
        renderer.domElement.addEventListener("pointermove", onMouseMove);

        // Ovl√°d√°n√≠
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 5000;

        // Zak√°zat prost≈ôedn√≠ tlaƒç√≠tko pro pan - pou≈æijeme ho pro v√Ωbƒõr pivot bodu
        controls.mouseButtons = {
          LEFT: THREE.MOUSE.ROTATE,
          MIDDLE: null, // Zak√°zat prost≈ôedn√≠ tlaƒç√≠tko
          RIGHT: THREE.MOUSE.PAN,
        };

        // Raycaster pro detekci my≈°i
        raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 20;
        mouse = new THREE.Vector2();

        // M≈ô√≠≈æka pro orientaci
        const gridHelper = new THREE.GridHelper(2000, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Osy
        const axesHelper = new THREE.AxesHelper(500);
        scene.add(axesHelper);

        // Event listenery
        window.addEventListener("resize", onWindowResize);
        // mousemove a mousedown jsou u≈æ p≈ôidan√© na canvas v√Ω≈°e, p≈ôed OrbitControls
        document
          .getElementById("csvFile")
          .addEventListener("change", handleFileSelect);
        document
          .getElementById("showAxes")
          .addEventListener("change", toggleAxesDisplay);
        document
          .getElementById("showLabels")
          .addEventListener("change", toggleLabelsDisplay);
        document
          .getElementById("useRadians")
          .addEventListener("change", toggleAngleMode);
        document
          .getElementById("rotationOrder")
          .addEventListener("change", changeRotationOrder);
        document
          .getElementById("pointSize")
          .addEventListener("input", updatePointSize);
        document
          .getElementById("axesSize")
          .addEventListener("input", updateAxesSize);
        document
          .getElementById("axesOpacity")
          .addEventListener("input", updateAxesOpacity);
        document
          .getElementById("darkMode")
          .addEventListener("change", toggleDarkMode);
        document
          .getElementById("showAxisX")
          .addEventListener("change", updateAxisVisibility);
        document
          .getElementById("showAxisY")
          .addEventListener("change", updateAxisVisibility);
        document
          .getElementById("showAxisZ")
          .addEventListener("change", updateAxisVisibility);
        document
          .getElementById("flipAxisX")
          .addEventListener("change", updateAxisFlip);
        document
          .getElementById("flipAxisY")
          .addEventListener("change", updateAxisFlip);
        document
          .getElementById("flipAxisZ")
          .addEventListener("change", updateAxisFlip);
        document
          .getElementById("languageToggle")
          .addEventListener("change", switchLanguage);
        document
          .getElementById("languageToggleLabel")
          .addEventListener("click", function() {
            document.getElementById("languageToggle").click();
          });

        animate();
      }

      function updatePointSize() {
        pointSize = parseInt(document.getElementById("pointSize").value);
        document.getElementById("pointSizeValue").textContent = pointSize;

        // Aktualizovat velikost bod≈Ø v point cloud
        if (pointObjects.length > 0) {
          pointObjects.forEach((pointCloud) => {
            pointCloud.material.size = pointSize;
            pointCloud.material.needsUpdate = true;
          });
        }
      }

      function updateAxesSize() {
        axesSize = parseInt(document.getElementById("axesSize").value);
        document.getElementById("axesSizeValue").textContent = axesSize;

        // P≈ôekreslit v≈°echny osov√© k≈ô√≠≈æe s novou velikost√≠
        if (csvData) {
          if (showAxesMode) {
            displayAllAxes();
          } else if (lastHoveredIndex !== null) {
            showHoverAxes(lastHoveredIndex);
          }
        }
      }

      function updateAxesOpacity() {
        const opacityValue = parseInt(
          document.getElementById("axesOpacity").value
        );
        axesOpacity = opacityValue / 100; // P≈ôev√©st z 0-100 na 0-1
        document.getElementById("axesOpacityValue").textContent =
          axesOpacity.toFixed(2);

        // P≈ôekreslit v≈°echny osov√© k≈ô√≠≈æe s novou transparentnost√≠
        if (csvData) {
          if (showAxesMode) {
            displayAllAxes();
          } else if (lastHoveredIndex !== null) {
            showHoverAxes(lastHoveredIndex);
          }
        }
      }

      function toggleDarkMode() {
        isDarkMode = document.getElementById("darkMode").checked;

        if (isDarkMode) {
          // Tmav√Ω re≈æim
          scene.background = new THREE.Color(0x1a1a1a);
        } else {
          // Svƒõtl√Ω re≈æim
          scene.background = new THREE.Color(0xe8e8e8);
        }

        // P≈ôekreslit body s nov√Ωmi barvami podle re≈æimu
        if (csvData) {
          updatePointColors();

          // P≈ôekreslit labely s nov√Ωmi barvami
          if (showLabelsMode) {
            displayAllLabels();
          }
        }
      }

      function updateAxisVisibility() {
        showAxisX = document.getElementById("showAxisX").checked;
        showAxisY = document.getElementById("showAxisY").checked;
        showAxisZ = document.getElementById("showAxisZ").checked;

        // P≈ôekreslit v≈°echny osov√© k≈ô√≠≈æe s novou viditelnost√≠
        if (csvData) {
          if (showAxesMode) {
            displayAllAxes();
          } else if (lastHoveredIndex !== null) {
            showHoverAxes(lastHoveredIndex);
          }
        }
      }

      function updateAxisFlip() {
        flipAxisX = document.getElementById("flipAxisX").checked;
        flipAxisY = document.getElementById("flipAxisY").checked;
        flipAxisZ = document.getElementById("flipAxisZ").checked;

        // P≈ôekreslit v≈°echny osov√© k≈ô√≠≈æe s nov√Ωm otoƒçen√≠m
        if (csvData) {
          if (showAxesMode) {
            displayAllAxes();
          } else if (lastHoveredIndex !== null) {
            showHoverAxes(lastHoveredIndex);
          }
        }
      }

      function updatePointColors() {
        if (pointObjects.length > 0 && csvData) {
          const colors = [];

          csvData.forEach((row) => {
            const y = parseFloat(row.p_y); // V√Ω≈°ka

            // Barva bod≈Ø podle re≈æimu
            const color = new THREE.Color();
            if (isDarkMode) {
              // Tmav√Ω re≈æim - modr√° s gradientem podle v√Ω≈°ky
              const hue = 0.6 + (y / 2000) * 0.2;
              color.setHSL(hue, 1.0, 0.6);
            } else {
              // Svƒõtl√Ω re≈æim - tmavomodr√° s gradientem
              const hue = 0.6 + (y / 2000) * 0.2;
              color.setHSL(hue, 0.8, 0.4);
            }
            colors.push(color.r, color.g, color.b);
          });

          // Aktualizovat barvy v geometrii
          pointObjects[0].geometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
          );
          pointObjects[0].geometry.attributes.color.needsUpdate = true;
        }
      }

      function changeRotationOrder() {
        rotationOrder = document.getElementById("rotationOrder").value;

        // P≈ôekreslit osov√© k≈ô√≠≈æe s nov√Ωm po≈ôad√≠m rotac√≠
        if (csvData) {
          if (showAxesMode) {
            displayAllAxes();
          } else if (lastHoveredIndex !== null) {
            showHoverAxes(lastHoveredIndex);
          }
        }
      }

      function degreesToRadians(degrees) {
        return degrees * (Math.PI / 180);
      }

      function getRotationValues(r_x, r_y, r_z) {
        if (useRadians) {
          // Pokud jsou hodnoty v radi√°nech, pou≈æ√≠t je p≈ô√≠mo
          return {
            x: parseFloat(r_x),
            y: parseFloat(r_y),
            z: parseFloat(r_z),
          };
        } else {
          // Pokud jsou hodnoty ve stupn√≠ch, p≈ôev√©st na radi√°ny
          return {
            x: degreesToRadians(parseFloat(r_x)),
            y: degreesToRadians(parseFloat(r_y)),
            z: degreesToRadians(parseFloat(r_z)),
          };
        }
      }

      function toggleAngleMode() {
        useRadians = document.getElementById("useRadians").checked;

        // P≈ôekreslit v≈°echny osov√© k≈ô√≠≈æe s nov√Ωm p≈ôepoƒçtem
        if (csvData) {
          if (showAxesMode) {
            displayAllAxes();
          } else if (lastHoveredIndex !== null) {
            showHoverAxes(lastHoveredIndex);
          }
        }
      }

      function createAxesHelper(position, rotation, customSize = null) {
        // Vytvo≈ôen√≠ skupiny pro osov√Ω k≈ô√≠≈æ
        const axesGroup = new THREE.Group();

        // Pou≈æ√≠t custom velikost nebo glob√°ln√≠ promƒõnnou
        const size = customSize !== null ? customSize : axesSize;

        // Vytvo≈ôen√≠ ≈°ipek pro osy X, Y, Z
        const axisLength = size;
        const headLength = size * 0.2;
        const headWidth = size * 0.15;

        // X osa - ƒçerven√° (pouze pokud je zapnut√°)
        if (showAxisX) {
          const xDirection = flipAxisX ? -1 : 1;
          const xAxis = new THREE.ArrowHelper(
            new THREE.Vector3(xDirection, 0, 0),
            new THREE.Vector3(0, 0, 0),
            axisLength,
            0xff0000,
            headLength,
            headWidth
          );
          xAxis.line.material.transparent = true;
          xAxis.line.material.opacity = axesOpacity;
          xAxis.cone.material.transparent = true;
          xAxis.cone.material.opacity = axesOpacity;
          axesGroup.add(xAxis);
        }

        // Y osa - zelen√° (pouze pokud je zapnut√°)
        if (showAxisY) {
          const yDirection = flipAxisY ? -1 : 1;
          const yAxis = new THREE.ArrowHelper(
            new THREE.Vector3(0, yDirection, 0),
            new THREE.Vector3(0, 0, 0),
            axisLength,
            0x00ff00,
            headLength,
            headWidth
          );
          yAxis.line.material.transparent = true;
          yAxis.line.material.opacity = axesOpacity;
          yAxis.cone.material.transparent = true;
          yAxis.cone.material.opacity = axesOpacity;
          axesGroup.add(yAxis);
        }

        // Z osa - modr√° (pouze pokud je zapnut√°)
        if (showAxisZ) {
          const zDirection = flipAxisZ ? -1 : 1;
          const zAxis = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, zDirection),
            new THREE.Vector3(0, 0, 0),
            axisLength,
            0x0000ff,
            headLength,
            headWidth
          );
          zAxis.line.material.transparent = true;
          zAxis.line.material.opacity = axesOpacity;
          zAxis.cone.material.transparent = true;
          zAxis.cone.material.opacity = axesOpacity;
          axesGroup.add(zAxis);
        }

        // Nastaven√≠ pozice
        axesGroup.position.copy(position);

        // Aplikace rotace z Euler √∫hl≈Ø (r_x, r_y, r_z)
        // Pou≈æ√≠t zvolen√© po≈ôad√≠ rotac√≠
        axesGroup.rotation.order = rotationOrder;
        axesGroup.rotation.set(rotation.x, rotation.y, rotation.z);

        return axesGroup;
      }

      function createTextSprite(text, position) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 128;
        canvas.height = 32;

        // Nastaven√≠ textu
        context.font = "16px Arial";
        context.fillStyle = isDarkMode
          ? "rgba(255, 255, 255, 0.9)"
          : "rgba(0, 0, 0, 0.9)";
        context.textAlign = "center";
        context.textBaseline = "middle";

        // Pozad√≠ pro lep≈°√≠ ƒçitelnost
        context.fillStyle = isDarkMode
          ? "rgba(0, 0, 0, 0.5)"
          : "rgba(255, 255, 255, 0.7)";
        context.fillRect(0, 0, canvas.width, canvas.height);

        // Text
        context.fillStyle = isDarkMode
          ? "rgba(255, 255, 255, 0.9)"
          : "rgba(0, 0, 0, 0.9)";
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        // Vytvo≈ôit texturu z canvasu
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;

        // Vytvo≈ôit sprite material
        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
        });

        // Vytvo≈ôit sprite
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(position);
        sprite.position.y += 30; // Posunout nad bod
        sprite.scale.set(100, 25, 1); // Velikost sprite

        return sprite;
      }

      function toggleLabelsDisplay() {
        showLabelsMode = document.getElementById("showLabels").checked;

        if (csvData) {
          if (showLabelsMode) {
            displayAllLabels();
          } else {
            hideAllLabels();
          }
        }
      }

      function displayAllLabels() {
        // Odstranit p≈ôedchoz√≠ labely
        hideAllLabels();

        // Vytvo≈ôit labely pro v≈°echny body
        csvData.forEach((row, index) => {
          const position = points[index].position.clone();
          const sprite = createTextSprite(row.name, position);
          scene.add(sprite);
          labelSprites.push(sprite);
        });
      }

      function hideAllLabels() {
        labelSprites.forEach((sprite) => scene.remove(sprite));
        labelSprites = [];
      }

      function toggleAxesDisplay() {
        showAxesMode = document.getElementById("showAxes").checked;

        if (csvData) {
          if (showAxesMode) {
            // Zobrazit v≈°echny osov√© k≈ô√≠≈æe
            displayAllAxes();
            // Skr√Ωt hover osu
            if (hoverAxesHelper) {
              scene.remove(hoverAxesHelper);
              hoverAxesHelper = null;
            }
          } else {
            // Skr√Ωt v≈°echny osov√© k≈ô√≠≈æe
            hideAllAxes();
          }
        }
      }

      function displayAllAxes() {
        // Odstranit p≈ôedchoz√≠ osy
        hideAllAxes();

        // Vytvo≈ôit osov√© k≈ô√≠≈æe pro v≈°echny body
        csvData.forEach((row) => {
          const x = parseFloat(row.p_x);
          const y = parseFloat(row.p_y);
          const z = parseFloat(row.p_z);

          const position = new THREE.Vector3(x, y, z);
          const rotation = getRotationValues(row.r_x, row.r_y, row.r_z);

          const axesHelper = createAxesHelper(
            position,
            new THREE.Vector3(rotation.x, rotation.y, rotation.z)
          );
          scene.add(axesHelper);
          axesObjects.push(axesHelper);
        });
      }

      function hideAllAxes() {
        axesObjects.forEach((axes) => scene.remove(axes));
        axesObjects = [];
      }

      function showHoverAxes(index) {
        if (!showAxesMode && csvData && csvData[index]) {
          // Odstranit p≈ôedchoz√≠ hover osu
          if (hoverAxesHelper) {
            scene.remove(hoverAxesHelper);
          }

          const row = csvData[index];
          const x = parseFloat(row.p_x);
          const y = parseFloat(row.p_y);
          const z = parseFloat(row.p_z);

          const position = new THREE.Vector3(x, y, z);
          const rotation = getRotationValues(row.r_x, row.r_y, row.r_z);

          hoverAxesHelper = createAxesHelper(
            position,
            new THREE.Vector3(rotation.x, rotation.y, rotation.z)
          );
          scene.add(hoverAxesHelper);
        }
      }

      function hideHoverAxes() {
        if (hoverAxesHelper) {
          scene.remove(hoverAxesHelper);
          hoverAxesHelper = null;
        }
      }

      function parseCSV(text) {
        const lines = text.trim().split("\n");
        const headers = lines[0].split(",");
        const data = [];

        for (let i = 1; i < lines.length; i++) {
          const values = lines[i].split(",");
          const obj = {};
          headers.forEach((header, index) => {
            obj[header.trim()] = values[index];
          });
          data.push(obj);
        }

        return data;
      }

      function loadPoints(data) {
        csvData = data;

        // Vymazat p≈ôedchoz√≠ body
        pointObjects.forEach((obj) => scene.remove(obj));
        pointObjects = [];
        points = [];
        hideAllAxes();
        hideHoverAxes();
        hideAllLabels();

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];

        csvData.forEach((row) => {
          const x = parseFloat(row.p_x);
          const y = parseFloat(row.p_y);
          const z = parseFloat(row.p_z);

          positions.push(x, y, z);

          // Barva bod≈Ø podle re≈æimu
          const color = new THREE.Color();
          const hue = 0.6 + (y / 2000) * 0.2; // Odst√≠n podle v√Ω≈°ky
          if (isDarkMode) {
            // Tmav√Ω re≈æim - svƒõtlej≈°√≠ modr√°
            color.setHSL(hue, 1.0, 0.6);
          } else {
            // Svƒõtl√Ω re≈æim - tmav≈°√≠ modr√°
            color.setHSL(hue, 0.8, 0.4);
          }
          colors.push(color.r, color.g, color.b);

          points.push({
            name: row.name,
            position: new THREE.Vector3(x, y, z),
          });
        });

        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3)
        );

        const material = new THREE.PointsMaterial({
          size: pointSize,
          vertexColors: true,
          sizeAttenuation: true,
        });

        const pointCloud = new THREE.Points(geometry, material);
        scene.add(pointCloud);
        pointObjects.push(pointCloud);

        // Vycentrovat kameru
        const box = new THREE.Box3().setFromObject(pointCloud);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= 1.5;

        camera.position.set(
          center.x + cameraZ,
          center.y + cameraZ,
          center.z + cameraZ
        );
        camera.lookAt(center);
        controls.target.copy(center);
        controls.update();

        const loadedText = translations[currentLanguage].status.loaded.replace(
          "{count}",
          points.length
        );
        document.getElementById("status").textContent = loadedText;

        // Pokud je zapnut√Ω re≈æim osov√Ωch k≈ô√≠≈æ≈Ø, zobrazit je
        if (showAxesMode) {
          displayAllAxes();
        }

        // Pokud je zapnut√Ω re≈æim label≈Ø, zobrazit je
        if (showLabelsMode) {
          displayAllLabels();
        }
      }

      function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function (e) {
            const csvData = parseCSV(e.target.result);
            loadPoints(csvData);
          };
          reader.readAsText(file);
        }
      }

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        if (pointObjects.length > 0) {
          const intersects = raycaster.intersectObjects(pointObjects);

          if (intersects.length > 0) {
            const intersect = intersects[0];
            const index = intersect.index;

            if (index !== undefined && points[index]) {
              const point = points[index];
              const x = point.position.x.toFixed(2);
              const y = point.position.y.toFixed(2);
              const z = point.position.z.toFixed(2);

              // Z√≠skat rotace z CSV dat
              const row = csvData[index];
              const rx = parseFloat(row.r_x).toFixed(2);
              const ry = parseFloat(row.r_y).toFixed(2);
              const rz = parseFloat(row.r_z).toFixed(2);
              const angleUnit = useRadians ? "rad" : "¬∞";

              const pointLabel = translations[currentLanguage].status.point;
              document.getElementById(
                "status"
              ).textContent = `${pointLabel} ${point.name} | [${x}, ${y}, ${z}, ${rx}${angleUnit}, ${ry}${angleUnit}, ${rz}${angleUnit}]`;
              document.body.style.cursor = "pointer";

              // Zobrazit osov√Ω k≈ô√≠≈æ p≈ôi hoveru (pouze kdy≈æ nen√≠ zapnut√Ω re≈æim v≈°ech k≈ô√≠≈æ≈Ø)
              if (!showAxesMode && lastHoveredIndex !== index) {
                showHoverAxes(index);
                lastHoveredIndex = index;
              }
            }
          } else {
            document.getElementById("status").textContent =
              translations[currentLanguage].status.hover;
            document.body.style.cursor = "default";

            // Skr√Ωt hover osov√Ω k≈ô√≠≈æ
            if (!showAxesMode) {
              hideHoverAxes();
              lastHoveredIndex = null;
            }
          }
        }
      }

      function onMouseDown(event) {
        // Prost≈ôedn√≠ tlaƒç√≠tko my≈°i (button = 1)
        if (event.button === 1) {
          event.preventDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();

          // Aktualizovat pozici my≈°i
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);

          let hitPoint = false;

          if (pointObjects.length > 0) {
            const intersects = raycaster.intersectObjects(pointObjects);

            if (intersects.length > 0) {
              const intersect = intersects[0];
              const index = intersect.index;

              if (index !== undefined && points[index]) {
                hitPoint = true;
                // Nastavit nov√Ω pivot bod
                const newPivot = points[index].position;

                // Vypoƒç√≠tat aktu√°ln√≠ vzd√°lenost kamery od star√©ho pivot bodu
                const currentDistance = camera.position.distanceTo(
                  controls.target
                );

                // Vypoƒç√≠tat smƒõr od star√©ho targetu k kame≈ôe
                const direction = new THREE.Vector3();
                direction
                  .subVectors(camera.position, controls.target)
                  .normalize();

                // Nastavit novou pozici kamery - stejn√° vzd√°lenost od nov√©ho pivot bodu
                const newCameraPos = new THREE.Vector3();
                newCameraPos
                  .copy(newPivot)
                  .add(direction.multiplyScalar(currentDistance));

                // Spustit animaci
                startCameraPos.copy(camera.position);
                targetCameraPos.copy(newCameraPos);
                startControlsTarget.copy(controls.target);
                targetControlsTarget.copy(newPivot);
                isAnimating = true;
                animationStart = null;

                // Aktualizovat status
                const pivotLabel =
                  translations[currentLanguage].status.pivotPoint;
                document.getElementById(
                  "status"
                ).textContent = `${pivotLabel} ${points[index].name}`;

                // Vytvo≈ôit nebo aktualizovat vizu√°ln√≠ marker
                createPivotMarker(newPivot);
              }
            }
          }

          // Pokud jsme neklikli na bod, nastavit st≈ôed na [0, 0, 0]
          if (!hitPoint) {
            const worldCenter = new THREE.Vector3(0, 0, 0);

            // Vypoƒç√≠tat aktu√°ln√≠ vzd√°lenost kamery od star√©ho pivot bodu
            const currentDistance = camera.position.distanceTo(controls.target);

            // Vypoƒç√≠tat smƒõr od star√©ho targetu k kame≈ôe
            const direction = new THREE.Vector3();
            direction.subVectors(camera.position, controls.target).normalize();

            // Nastavit novou pozici kamery - stejn√° vzd√°lenost od svƒõtov√©ho st≈ôedu
            const newCameraPos = new THREE.Vector3();
            newCameraPos
              .copy(worldCenter)
              .add(direction.multiplyScalar(currentDistance));

            // Spustit animaci
            startCameraPos.copy(camera.position);
            targetCameraPos.copy(newCameraPos);
            startControlsTarget.copy(controls.target);
            targetControlsTarget.copy(worldCenter);
            isAnimating = true;
            animationStart = null;

            // Aktualizovat status
            const pivotLabel = translations[currentLanguage].status.pivotPoint;
            const worldCenterLabel =
              translations[currentLanguage].status.worldCenter;
            document.getElementById(
              "status"
            ).textContent = `${pivotLabel} ${worldCenterLabel} [0, 0, 0]`;

            // Vytvo≈ôit nebo aktualizovat vizu√°ln√≠ marker
            createPivotMarker(worldCenter);
          }
        }
      }

      function updateCameraAnimation(timestamp) {
        if (!isAnimating) return;

        if (animationStart === null) {
          animationStart = timestamp;
        }

        const elapsed = timestamp - animationStart;
        const progress = Math.min(elapsed / animationDuration, 1);

        // Easing function (ease-in-out)
        const eased =
          progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        // Interpolace pozice kamery
        camera.position.lerpVectors(startCameraPos, targetCameraPos, eased);
        controls.target.lerpVectors(
          startControlsTarget,
          targetControlsTarget,
          eased
        );
        controls.update();

        if (progress >= 1) {
          isAnimating = false;
        }
      }

      function updatePivotMarkerFade(timestamp) {
        if (!pivotMarker) return;

        if (pivotMarkerFadeStart === null) {
          pivotMarkerFadeStart = timestamp;
        }

        const elapsed = timestamp - pivotMarkerFadeStart;
        const progress = Math.min(elapsed / pivotMarkerFadeDuration, 1);

        // Aktualizovat fade progress v shaderu
        if (pivotMarker.material.uniforms) {
          pivotMarker.material.uniforms.fadeProgress.value = progress;
        }

        // Po dokonƒçen√≠ animace odstranit marker
        if (progress >= 1) {
          scene.remove(pivotMarker);
          pivotMarker = null;
          pivotMarkerFadeStart = null;
        }
      }

      function createPivotMarker(position) {
        // Odstranit p≈ôedchoz√≠ marker
        if (pivotMarker) {
          scene.remove(pivotMarker);
        }

        // Vytvo≈ôit nov√Ω marker s gradientn√≠ barvou
        const geometry = new THREE.SphereGeometry(20, 32, 32);

        // Vytvo≈ôit shader material pro gradientn√≠ efekt
        const material = new THREE.ShaderMaterial({
          transparent: true,
          uniforms: {
            fadeProgress: { value: 0.0 },
          },
          vertexShader: `
            varying vec3 vNormal;
            void main() {
              vNormal = normalize(normalMatrix * normal);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float fadeProgress;
            varying vec3 vNormal;
            void main() {
              // Gradient od oran≈æov√© ke ≈ælut√©
              vec3 color1 = vec3(1.0, 0.6, 0.0); // Oran≈æov√°
              vec3 color2 = vec3(1.0, 1.0, 0.0); // ≈Ωlut√°

              // Gradient na z√°kladƒõ norm√°ly (vrchol -> spodek)
              float gradient = (vNormal.y + 1.0) * 0.5;
              vec3 color = mix(color1, color2, gradient);

              // Fade out efekt
              float alpha = 0.8 * (1.0 - fadeProgress);

              gl_FragColor = vec4(color, alpha);
            }
          `,
        });

        pivotMarker = new THREE.Mesh(geometry, material);
        pivotMarker.position.copy(position);
        scene.add(pivotMarker);

        // Spustit fade animaci
        pivotMarkerFadeStart = null;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate(timestamp) {
        requestAnimationFrame(animate);

        // Aktualizovat animaci p≈ôesunu kamery
        updateCameraAnimation(timestamp);

        // Aktualizovat fade animaci pivot markeru
        updatePivotMarkerFade(timestamp);

        controls.update();
        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
